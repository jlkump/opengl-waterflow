#version 430

layout(local_size_x=1, local_size_y=1, local_size_z=1) in; // One local worker per worker group

layout (std430, binding = 0) buffer bounds {
	vec3 upper_bound;
	vec3 lower_bound;
};

layout (rgba32f, binding = 1) uniform image2D particle_pos_old;
layout (rgba32f, binding = 2) uniform image2D particle_pos_new;

layout (rgba32f, binding = 3) uniform image2D particle_vel_old; // Probably only need one velocity texture
layout (rgba32f, binding = 4) uniform image2D particle_vel_new;

layout(r32ui) uniform uimage3D locks; // The locks for accessing the data of grid_vel
layout (rgba32f, binding = 5) uniform image3D grid_vel; // Id by position rather than work group. Will require atomic access to the same positions

uniform float deltaTime;
uniform float particleRadius;
// uniform vec2 texBounds;

#define GRAVITY vec3(0.0, -9.8, 0.0)

void aquire_lock(ivec3 pos) {
	while (imageAtomicExchange(locks, pos, 1) == 1) {
		; // Wait when the lock value is equal to one
	}
}

void release_lock(ivec3 pos) {
	imageAtomicExchange(locks, pos, 0); // This should always return 1, since we only call when we hold the lock
}

void write_to_grid(ivec3 pos, vec3 vel) 
{
	aquire_lock(pos);
	vec3 previous = imageLoad(grid_vel, pos).xyz;
	imageStore(grid_vel, pos, vec4(previous + vel, 1.0));
	release_lock(pos);
}

void main() 
{
	
	ivec2 id = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	vec3 vel_old = imageLoad(particle_vel_old, id).xyz;
	vec3 vel_new = vel_old + GRAVITY * deltaTime;
	vec3 pos_new = imageLoad(particle_pos_old, id).xyz + vel_new * deltaTime *.1;

	if (pos_new.x <= lower_bound.x) {
	 	pos_new.x = lower_bound.x;
	}
	if (pos_new.y <= lower_bound.y) {
		pos_new.y = lower_bound.y;
	}
	if (pos_new.z <= lower_bound.z) {
		pos_new.z = lower_bound.z;
	}
	
	if (pos_new.x >= upper_bound.x) {
		pos_new.x = upper_bound.x;
	}
	if (pos_new.y >= upper_bound.y) {
		pos_new.y = upper_bound.y;
	}
	if (pos_new.z >= upper_bound.z) {
		pos_new.z = upper_bound.z;
	}
	
	imageStore(particle_pos_old, id, vec4(pos_new, 1.0));
	imageStore(particle_vel_old, id, vec4(vel_new, 1.0));
	
	write_to_grid();

}