#version 430

layout(local_size_x=1, local_size_y=1, local_size_z=1) in; // One local worker per worker group

layout (rgba32f, binding = 0) uniform image3D grid_vel;
layout (rgba32f, binding = 1) uniform image3D grid_new_vel;
layout (r32ui, binding = 2) uniform uimage3D grid_is_fluid;
layout (r32ui, binding = 3) uniform uimage3D grid_cell_type; // 0 is solid, 1 is fluid, 2 is air
layout (r32f, binding = 4) uniform image3D grid_pressures;

uniform float cp; // = density_ * ws_grid_interval_ / delta; // For pressure calc

float GetDivergence(ivec3 pos_id) {
	vec3 cell = imageLoad(grid_vel, pos_id).xyz;
	vec3 cell_x = imageLoad(grid_vel, pos_id + ivec3(1, 0, 0)).xyz;
	vec3 cell_y = imageLoad(grid_vel, pos_id + ivec3(0, 1, 0)).xyz;
	vec3 cell_z = imageLoad(grid_vel, pos_id + ivec3(0, 0, 1)).xyz;

	return cell_x.x - cell.x + cell_y.y - cell.y + cell_z.z - cell.z;
}

void main() {
	ivec3 pos_id = ivec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z);
	uint cell_type = imageLoad(grid_cell_type, pos_id).x;
	if (cell_type == 1) {
		// Only process cells that are fluid cells
		float s = imageLoad(grid_is_fluid, pos_id).x;
		float s_x_neg = imageLoad(grid_is_fluid, pos_id + ivec3(-1, 0, 0)).x;
		float s_x_pos = imageLoad(grid_is_fluid, pos_id + ivec3(1, 0, 0)).x;
		float s_y_neg = imageLoad(grid_is_fluid, pos_id + ivec3(0, -1, 0)).x;
		float s_y_pos = imageLoad(grid_is_fluid, pos_id + ivec3(0, 1, 0)).x;
		float s_z_neg = imageLoad(grid_is_fluid, pos_id + ivec3(0, 0, -1)).x;
		float s_z_pos = imageLoad(grid_is_fluid, pos_id + ivec3(0, 0, 1)).x;

		s = s_x_neg + s_x_pos + s_y_neg + s_y_pos + s_z_neg + s_z_pos;

		float total_divergence = GetDivergence(pos_id);
		
		vec3 v_cur = imageLoad(grid_vel, pos_id).xyz;
		vec3 v_x_pos = imageLoad(grid_vel, pos_id + ivec3(1, 0, 0)).xyz;
		vec3 v_y_pos = imageLoad(grid_vel, pos_id + ivec3(0, 1, 0)).xyz;
		vec3 v_z_pos = imageLoad(grid_vel, pos_id + ivec3(0, 0, 1)).xyz;

		float p = -total_divergence / s;
		imageStore(grid_pressures, pos_id, imageLoad(grid_pressures, pos_id) + cp * p);

		v_cur.x -= s_x_neg * p;
		v_cur.y -= s_y_neg * p;
		v_cur.z -= s_z_neg * p;
		v_x_pos.x += s_x_pos * p;
		v_y_pos.y += s_y_pos * p;
		v_z_pos.z += s_z_pos * p;

		imageStore(grid_new_vel, pos_id, vec4(v_cur, 0.0));
		imageStore(grid_new_vel, pos_id + ivec3(1, 0, 0), vec4(v_x_pos, 0.0));
		imageStore(grid_new_vel, pos_id + ivec3(0, 1, 0), vec4(v_y_pos, 0.0));
		imageStore(grid_new_vel, pos_id + ivec3(0, 0, 1), vec4(v_z_pos, 0.0));
	}
}