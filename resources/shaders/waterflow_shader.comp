#version 430

// Built-in input variables
//	in uvec3 gl_NumWorkGroups;  This variable contains the number of work groups passed to the dispatch function.
// 
//	in uvec3 gl_WorkGroupID;    This is the current work group for this shader invocation. 
//								Each of the XYZ components will be on the half-open range [0, gl_NumWorkGroups.XYZ).
// 
//	in uvec3 gl_LocalInvocationID;		This is the current invocation of the shader within the work group. 
//										Each of the XYZ components will be on the half-open range [0, gl_WorkGroupSize.XYZ).
//
//	in uvec3 gl_GlobalInvocationID;		This value uniquely identifies this particular invocation of the compute 
//										shader among all invocations of this compute dispatch call. 
//										It's a short-hand for the math computation: 
//										"gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;"
//
//	in uint  gl_LocalInvocationIndex;	This is a 1D version of gl_LocalInvocationID. 
//										It identifies this invocation's index within the work group. 
//										It is short-hand for this math computation:
//										gl_LocalInvocationIndex =
//                                      gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y +
//                                      gl_LocalInvocationID.y * gl_WorkGroupSize.x + 
//										gl_LocalInvocationID.x;
// 
//  const uvec3 gl_WorkGroupSize;		The size of the work group.

// The size of the local group. Idk how big this needs to be yet, so just make it the smallest for now.
layout(local_size_x=1, local_size_y=1, local_size_z=1) in; 

// Shared read-only variables stored in a Shader Storage Buffer Object
layout (std430, binding = 0) buffer variables 
{
	// Variables in struct-like syntax
	float time;
	float deltaTime;
};

layout (binding = 1, rgba32f) uniform image2D diffusion_old;
layout (binding = 2, rgba32f) uniform image2D diffusion_new; // This will be the color displayed for now.

//// Simulation based textures
//layout (binding = 1, rgba32f) uniform image2D water_vel_old; // Previous water sim velocity values
//layout (binding = 2, rgba32f) uniform image2D water_vel_new; // Values to be updated
//
//// The actual textures we output
//layout (binding = 3, rgba32f) uniform image2D water_normals; // The texture to actually display based on values 
//layout (binding = 4, r32f) uniform image2D water_heightmap; // The texture to actually display based on values 

// Explanation of fluid simulation from Gonkee's youtube video "But How DO Fluid Simulations Work?"
// https://www.youtube.com/watch?v=qsYE1wMEMPA&t=320s

void LinearSolve(vec3[1] v, vec3[5] v0, float coefficient, float denominator) 
{
	// d0[0] == (x, y)
	// d0[1] == (x + 1, y)
	// d0[2] == (x, y + 1)
	// d0[3] == (x - 1, y)
	// d0[4] == (x, y - 1)

	v[0].xyz = v0[0].xyz + (coefficient * (v0[1].xyz + v0[2].xyz + v0[3].xyz + v0[4].xyz)) / denominator;
}

void main() 
{
	// We will assume for now that each worker gets assigned its own pixel
	vec3 d0 = imageLoad(diffusion_old, ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y)).rgb; 
	// d = (d0 + k * s) / (1 + k)
	// s0 is the average of the diffusion of the old surrounding cells.
	// s is the average of the diffusion of the new surrounding cells.
	vec3 d[1] = { d0 };
	vec3 d_old[5] = { d0, 
						imageLoad(diffusion_old, ivec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y)).rgb,
						imageLoad(diffusion_old, ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y + 1)).rgb,
						imageLoad(diffusion_old, ivec2(gl_WorkGroupID.x - 1, gl_WorkGroupID.y)).rgb,
						imageLoad(diffusion_old, ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y - 1)).rgb };
	float k = deltaTime; // The amount of change done 
	LinearSolve(d, d_old, k, k + 1);
	LinearSolve(d, d_old, k, k + 1);
	LinearSolve(d, d_old, k, k + 1);
	LinearSolve(d, d_old, k, k + 1);


	// Since we have a 2D image, coordinate is a vec2
	// and vec4 is for the data we actually want to store.
	imageStore(diffusion_new, ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y), vec4(d[0].rgb, 1.0));

	// Prevents other threads from getting ahead until everyone reaches this point.
	barrier();

	imageStore(diffusion_old, ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y), vec4(d[0].rgb, 1.0));
}