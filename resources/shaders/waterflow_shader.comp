#version 430

// Built-in input variables
//	in uvec3 gl_NumWorkGroups;  This variable contains the number of work groups passed to the dispatch function.
// 
//	in uvec3 gl_WorkGroupID;    This is the current work group for this shader invocation. 
//								Each of the XYZ components will be on the half-open range [0, gl_NumWorkGroups.XYZ).
// 
//	in uvec3 gl_LocalInvocationID;		This is the current invocation of the shader within the work group. 
//										Each of the XYZ components will be on the half-open range [0, gl_WorkGroupSize.XYZ).
//
//	in uvec3 gl_GlobalInvocationID;		This value uniquely identifies this particular invocation of the compute 
//										shader among all invocations of this compute dispatch call. 
//										It's a short-hand for the math computation: 
//										"gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;"
//
//	in uint  gl_LocalInvocationIndex;	This is a 1D version of gl_LocalInvocationID. 
//										It identifies this invocation's index within the work group. 
//										It is short-hand for this math computation:
//										gl_LocalInvocationIndex =
//                                      gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y +
//                                      gl_LocalInvocationID.y * gl_WorkGroupSize.x + 
//										gl_LocalInvocationID.x;
// 
//  const uvec3 gl_WorkGroupSize;		The size of the work group.

// The size of the local group. Idk how big this needs to be yet, so just make it the smallest for now.
layout(local_size_x=1, local_size_y=1, local_size_z=1) in; 

// Shared read-only variables stored in a Shader Storage Buffer Object
layout (std430, binding = 0) buffer variables 
{
	// Variables in struct-like syntax
	float time;
	float deltaTime;
};

layout (rgba32f, binding = 1) uniform image2D diffusion_old;
layout (rgba32f, binding = 2) uniform image2D diffusion_new; // This will be the color displayed for now.

layout (rgba32f, binding = 3) uniform image2D velocity_old;
layout (rgba32f, binding = 4) uniform image2D velocity_new;

//// Simulation based textures
//layout (binding = 1, rgba32f) uniform image2D water_vel_old; // Previous water sim velocity values
//layout (binding = 2, rgba32f) uniform image2D water_vel_new; // Values to be updated
//
//// The actual textures we output
//layout (binding = 3, rgba32f) uniform image2D water_normals; // The texture to actually display based on values 
//layout (binding = 4, r32f) uniform image2D water_heightmap; // The texture to actually display based on values 

// Explanation of fluid simulation from Gonkee's youtube video "But How DO Fluid Simulations Work?"
// https://www.youtube.com/watch?v=qsYE1wMEMPA&t=320s


// Return the new value
vec3 LinearSolve(vec3 old_val, vec3 old_neighbors[4], float numerator, float denominator) 
{
	vec3 new_neighbors[4] = {vec3(0, 0, 0), vec3(0,0,0), vec3(0,0,0), vec3(0,0,0)};
	new_neighbors[0] = (old_neighbors[0] + numerator * ((new_neighbors[1] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;
	new_neighbors[1] = (old_neighbors[1] + numerator * ((new_neighbors[0] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;
	new_neighbors[2] = (old_neighbors[2] + numerator * ((new_neighbors[1] + new_neighbors[0] + new_neighbors[3]) / 4)) / denominator;
	new_neighbors[3] = (old_neighbors[3] + numerator * ((new_neighbors[1] + new_neighbors[2] + new_neighbors[0]) / 4)) / denominator;
	vec3 new_val = (old_val + numerator * ((new_neighbors[0] + new_neighbors[1] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;

	//  Repeat the number of solves for Gauss Seidel solver to get closer approximate. About 2 seems good for now
	new_neighbors[0] = (old_neighbors[0] + numerator * ((new_neighbors[1] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;
	new_neighbors[1] = (old_neighbors[1] + numerator * ((new_neighbors[0] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;
	new_neighbors[2] = (old_neighbors[2] + numerator * ((new_neighbors[1] + new_neighbors[0] + new_neighbors[3]) / 4)) / denominator;
	new_neighbors[3] = (old_neighbors[3] + numerator * ((new_neighbors[1] + new_neighbors[2] + new_neighbors[0]) / 4)) / denominator;
	new_val = (old_val + numerator * ((new_neighbors[0] + new_neighbors[1] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;

//	new_neighbors[0] = (old_neighbors[0] + numerator * ((new_neighbors[1] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;
//	new_neighbors[1] = (old_neighbors[1] + numerator * ((new_neighbors[0] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;
//	new_neighbors[2] = (old_neighbors[2] + numerator * ((new_neighbors[1] + new_neighbors[0] + new_neighbors[3]) / 4)) / denominator;
//	new_neighbors[3] = (old_neighbors[3] + numerator * ((new_neighbors[1] + new_neighbors[2] + new_neighbors[0]) / 4)) / denominator;
//	new_val = (old_val + numerator * ((new_neighbors[0] + new_neighbors[1] + new_neighbors[2] + new_neighbors[3]) / 4)) / denominator;

	return new_val;
}

void DiffuseDye(ivec2 pos) 
{

	// d = (d0 + k * s) / (1 + k)
	// s0 is the average of the diffusion of the old surrounding cells.
	// s is the average of the diffusion of the new surrounding cells.

	// We will assume for now that each worker gets assigned its own pixel
	vec3 d0 = imageLoad(diffusion_old, pos).rgb; 

	vec3 d_old[4] = {
						imageLoad(diffusion_old, ivec2(pos.x + 1, pos.y)).rgb,
						imageLoad(diffusion_old, ivec2(pos.x, pos.y + 1)).rgb,
						imageLoad(diffusion_old, ivec2(pos.x - 1, pos.y)).rgb,
						imageLoad(diffusion_old, ivec2(pos.x, pos.y - 1)).rgb };
	float k = deltaTime * 10; // The amount of change done 
	vec3 d = LinearSolve(d0, d_old, k, k + 1);
	imageStore(diffusion_new, pos, vec4(d.rgb, 1.0));
}

void DiffuseVel(ivec2 pos) 
{
	vec3 v0 = imageLoad(velocity_old, pos).rgb;

	vec3 v_old[4] = {
						imageLoad(velocity_old, ivec2(pos.x + 1, pos.y)).rgb,
						imageLoad(velocity_old, ivec2(pos.x, pos.y + 1)).rgb,
						imageLoad(velocity_old, ivec2(pos.x - 1, pos.y)).rgb,
						imageLoad(velocity_old, ivec2(pos.x, pos.y - 1)).rgb };
	float k = deltaTime * 10;
	vec3 v = LinearSolve(v0, v_old, k, k + 1);
	imageStore(velocity_new, pos, vec4(v.rgb, 1.0));
}

// Projection ensures that the fluid remains incompressible
void Project(ivec2 pos) 
{
	
}

// Advection carries what is in the fluid further along the fluid
// This includes both velocities and dye.
void Advect() 
{
	// TODO
}

void UpdateOldValues(ivec2 pos) {
	imageStore(diffusion_old, pos, imageLoad(diffusion_new, pos));
	imageStore(velocity_old, pos, imageLoad(velocity_new, pos));
}

void main() 
{
	ivec2 pos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	DiffuseDye(pos);

	// Prevents other threads from getting ahead until everyone reaches this point.
	barrier();
	UpdateOldValues(pos);
	
}